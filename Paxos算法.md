## Paxos算法
一种基于消息传递且具有高度容错特性的一致性算法。<br>
在不考虑拜占庭问题的情况下（没有“叛徒”）的高容错的一致性算法。<br>
Paxos算法解决的问题是在一个可能发生消息可能会延迟、丢失、重复的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的一致性。<br>
一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。

### 内容描述
在一个虚拟的Paxos的城邦，按照议会民主制的政治模式制订法律，
但是没有人愿意将自己的全部时间和精力放在这种事情上。所以无论是议员，
议长或者传递纸条的服务员都不能承诺别人需要时一定会出现，
也无法承诺批准决议或者传递消息的时间。
但是这里假设没有拜占庭将军问题
（Byzantine failure，即虽然有可能一个消息被传递了两次，但是绝对不会出现错误的消息）；
只要等待足够的时间，消息就会被传到。另外，Paxos岛上的议员是不会反对其他议员提出的决议的。 <br>

### 算法描述
角色分为 proposers，acceptors，和 learners（允许身兼数职）。
proposers 提出提案，提案信息包括提案编号和提议的 value；
acceptor 收到提案后可以接受（accept）提案，
若提案获得多数派（majority）的 acceptors 的接受，则称该提案被批准（chosen）；
learners 只能“学习”被批准的提案。<br>
即：<br>
* 1.决议（value）只有在被 proposers 提出后才能被批准（未经批准的决议称为“提案（proposal）”）
* 2.在一次 Paxos 算法的执行实例中，只批准（chosen）一个 value
* 3.learners 只能获得被批准（chosen）的 value
