## 问题描述：
n个将军分隔在不同地方，忠诚的将军想以某种协议达成*一致*。但是背叛的将军会通过错误信息阻挠。

##  问题证明满足以下默认条件：
* 1.每个消息被正确发送。(无干扰)
* 2.消息的接收者知道是谁发送的消息。
* 3.可以被检测到缺少消息。

## 描述简化：
将此时发令的将军称为发令者，接收命令的将军称为副官。默认命令为撤退。(默认命令也可以为进攻，只需要所有副官的默认命令一致即可)
### （忠诚）副官满足以下规则：
* 1.每两个忠诚副官收到的来自第i个副官的命令相同（设为Vi）
* 2.若第i个副官忠诚，则其收到的命令与任意其他忠诚的将军相同。

以上描述可以总结为以下两个条件：
* IC1.所有忠诚副官遵守同一命令。 -> 一致性
* IC2.如果司令官是忠诚的，每个忠诚的副官遵守他的命令。 -> 正确性

满足以上两个条件的情况下，忠诚的将军可以达成一致。

## 算法：OM(m), m是非负整数。m是叛徒个数。
### m=0：
```
  (1) 发令者发送他的值给每个副官。
  (2) 如果副官收到发令者的值，使用这个值；否则，使用默认值——“撤退”。
```
### m>0：
```
(1) 发令者发送他的值给每个副官。
(2) 对于每个i，令vi为副官i从发令者接收到的值；如果没有收到值，则vi采用默认值——“撤退”。在OM(m-1)算法中，副官i作为发令者向另外n-2个副官(不包括OM(m)中的发令者)发送值vi。
(3) 对于每个i，对于每个j≠i的j，令vi为副官i在第(2)步中从副官j接收的值；如果没有接收到值，则使用默认值——“撤退”。副官i用majority(v1,...,vn−1)作为其值。

```
    
## 证明尝试：n个将军中存在m个叛徒
### 情况a：
  n=4,m=1：将军中有一个叛徒
  #### 发令者忠诚的情况，副官有一个叛徒。
  ![](https://github.com/liuzhen910201/Byzantine-failures/blob/master/m4n1.png)
  
* 1.OM(1):发令者向每个副官发送他的值vv给每个副官。
* 2.OM(0):副官1执行OM(0)，作为发令者向副官2发送v；由于副官3是叛徒，其执行OM(0)向副官2发送了不同的值，假设为x。
* 3.副官2拥有的行动值集为{v1,v2,v3}={v,v,x}{v1,v2,v3}={v,v,x}，采用majority函数，副官2采取的行动值为v=majority{v1,v2,v3}v=majority{v1,v2,v3}。

#### 发令者是叛徒，副官没有叛徒
![](https://github.com/liuzhen910201/Byzantine-failures/blob/master/m4n1_2.png)

* 1.OM(1):发令者为了阻止忠诚副官达成一致，分别向三位副官发送值{x,y,z}。
* 2.OM(0):每个副官从发令者收到的值作为自己的值，并执行OM(0)向其他副官发送。
* 3.在第三步中，每个副官拥有的值集均为{x,y,z}，因此，副官执行行动函数majority得到的结果是一样的。
