## 问题描述：
n个将军分隔在不同地方，忠诚的将军想以某种协议达成*一致*。但是背叛的将军会通过错误信息阻挠。

##  问题证明满足以下默认条件：
* 1.每个消息被正确发送。(无干扰)
* 2.消息的接收者知道是谁发送的消息。
* 3.可以被检测到缺少消息。

## 描述简化：
将此时发令的将军称为发令者，接收命令的将军称为副官。默认命令为撤退。(默认命令也可以为进攻，只需要所有副官的默认命令一致即可)
### （忠诚）副官满足以下规则：
* 1.每两个忠诚副官收到的来自第i个副官的命令相同（设为Vi）
* 2.若第i个副官忠诚，则其收到的命令与任意其他忠诚的将军相同。

以上描述可以总结为以下两个条件：
* IC1.所有忠诚副官遵守同一命令。 -> 一致性
* IC2.如果司令官是忠诚的，每个忠诚的副官遵守他的命令。 -> 正确性

满足以上两个条件的情况下，忠诚的将军可以达成一致。

## 算法：OM(m), m是非负整数。m是叛徒个数。
### m=0：
```
  (1) 发令者发送他的值给每个副官。
  (2) 如果副官收到发令者的值，使用这个值；否则，使用默认值——“撤退”。
```
### m>0：
```
(1) 发令者发送他的值给每个副官。
(2) 对于每个ii，令vivi​为副官ii从司令接收到的值；如果没有收到值，则vivi​采用默认值——“撤退”。在***OM(m-1)***算法中，副官ii作为发令者向另外***n-2**个副官(不包括OM(m)*中的发令者)发送值vivi​。
(3) 对于每个ii，对于每个j≠i的j，令vivi​为副官ii在第(2)步中从副官jj接收的值；如果没有接收到值，则使用默认值——“撤退”。副官ii用majority(v1,...,vn−1)majority(v1​,...,vn−1​)作为其值。
```
    
## 证明尝试：n个将军中存在m个叛徒
### 情况a：
  n=4,m=1：将军中有一个叛徒
  #### 发令者忠诚的情况，副官有一个叛徒。
  ![](https://github.com/liuzhen910201/Byzantine-failures/blob/master/m4n1.png)
  
* 1.发令者向每个副官发送他的值vv给每个副官。
* 2.副官1执行OM(0)，作为发令者向副官2发送v；由于副官3是叛徒，其执行OM(0)向副官2发送了不同的值，假设为x。
* 3.副官2拥有的行动值集为{v1,v2,v3}={v,v,x}{v1​,v2​,v3​}={v,v,x}，采用majority函数，副官2采取的行动值为v=majority{v1,v2,v3}v=majority{v1​,v2​,v3​}。

#### 发令者是叛徒，副官没有叛徒
![](https://github.com/liuzhen910201/Byzantine-failures/blob/master/m4n1_2.png)


