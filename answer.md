## 问题描述：
n个将军分隔在不同地方，忠诚的将军想以某种协议达成*一致*。但是背叛的将军会通过错误信息阻挠。

##  问题证明满足以下默认条件：
* 1.每个消息被正确发送。(无干扰)
* 2.消息的接收者知道是谁发送的消息。
* 3.可以被检测到缺少消息。

## 描述简化：
将此时发令的将军称为发令者，接收命令的将军称为副官。默认命令为撤退。(默认命令也可以为进攻，只需要所有副官的默认命令一致即可)
### （忠诚）副官满足以下规则：
* 1.每两个忠诚副官收到的来自第i个副官的命令相同（设为Vi）
* 2.若第i个副官忠诚，则其收到的命令与任意其他忠诚的将军相同。

以上描述可以总结为以下两个条件：
* IC1.所有忠诚副官遵守同一命令。 -> 一致性
* IC2.如果司令官是忠诚的，每个忠诚的副官遵守他的命令。 -> 正确性

满足以上两个条件的情况下，忠诚的将军可以达成一致。

## 算法：OM(m), m是非负整数。m是叛徒个数。
### m=0：
```
  (1) 发令者发送他的值给每个副官。
  (2) 如果副官收到发令者的值，使用这个值；否则，使用默认值——“撤退”。
```
### m>0：
```
(1) 发令者发送他的值给每个副官。
(2) 对于每个ii，令vivi​为副官ii从司令接收到的值；如果没有收到值，则vivi​采用默认值——“撤退”。在***OM(m-1)***算法中，副官ii作为发令者向另外***n-2**个副官(不包括OM(m)*中的发令者)发送值vivi​。
(3) 对于每个ii，对于每个j≠i的j，令vivi​为副官ii在第(2)步中从副官jj接收的值；如果没有接收到值，则使用默认值——“撤退”。副官ii用majority(v1,...,vn−1)majority(v1​,...,vn−1​)作为其值。
```
    
## 证明尝试：n个将军中存在m个叛徒
### 情况a：
  n=4,m=1：4个将军中有一个叛徒
  #### 发令者忠诚的情况，副官有一个叛徒。
  
