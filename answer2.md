## 问题描述：
n个将军分隔在不同地方，忠诚的将军想以某种协议达成*一致*。但是背叛的将军会通过错误信息阻挠。

##  问题证明满足以下默认条件：
* 1.每个消息被正确发送。(无干扰)
* 2.消息的接收者知道是谁发送的消息。
* 3.可以被检测到缺少消息。

## 描述简化：
将此时发令的将军称为发令者，接收命令的将军称为副官。默认命令为撤退。(默认命令也可以为进攻，只需要所有副官的默认命令一致即可)
### （忠诚）副官满足以下规则：
* 1.每两个忠诚副官收到的来自第i个副官的命令相同（设为Vi）
* 2.若第i个副官忠诚，则其收到的命令与任意其他忠诚的将军相同。

以上描述可以总结为以下两个条件：
* IC1.所有忠诚副官遵守同一命令。 -> 一致性
* IC2.如果司令官是忠诚的，每个忠诚的副官遵守他的命令。 -> 正确性

满足以上两个条件的情况下，忠诚的将军可以达成一致。

## 解答
### 情况1.司令官忠诚
所有副官所得到的命令相同。易得，副官中叛徒人数不超过半数时，所有忠诚的副官可以得到一致命令。

* 可参考以下引理证明：
```
  对于任意的mm和kk，如果在多于2k+m2k+m个将军中至多存在kk个叛徒，则OM(m)算法满足条件IC2。
```
证明： 归纳法，针对参数m
m进行归纳。
当m=0时，
根据假设A1和OM(0)算法，易得如果司令是忠诚的，忠诚的将军按照司令的指令行动，引理是成立的。

当m>0时，假设在m−1时，引理成立，下面来证明在m，引理也成立。
在OM(m)的第一步，司令发送值v
v给他的n−1个副官；
在第二步，每个忠诚的副官在n−1个副官中执行OM(m-1)算法。根据假设n>2k+mn>2k+m，则n−1>2k+(m−1)n−1>2k+(m−1)，所以根据引理在m−1m−1时成立，可得，每个忠诚的将军从忠诚的将军jj处获得的值为vj=v。

在第三步中，由于叛徒最多有k个，且n−1>2k+(m−1)≥2kn−1>2k+(m−1)≥2k，所以n−1n−1个将军中的忠诚将军为大多数。所以第三步每个忠诚的将军获得值majority(v1,...,vn−1)=v，满足条件IC2。

引理得证。

### 情况2.司令官是叛徒
根据IC1,所有忠诚副官遵循同样的命令，即得到的命令的排列组合相同（无序）

 ![](https://github.com/liuzhen910201/Byzantine-failures/blob/master/m_1_n_1.png)
 
 OM(0)=major(Vm-1...Vn-1)，所有忠诚副官的OM（0）需要得到相同结果，所以major(Vm-1...Vn-1）相同。
 所以，(n-1)-(m-1)个副官中的叛徒数量不能超过一半。
 需要考虑极端情况，所有的m个叛徒都在这(n-1)-(m-1)个副官中，
 所以，(n-1)-(m-1)>2m。
 可得，m<n/3。
 
 以上。
